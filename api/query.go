package api

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"

	"reflect"

	_ "github.com/go-sql-driver/mysql"
	db "github.com/scribe-org/scribe-server/db/gen"
)

func getTables(w http.ResponseWriter, r *http.Request) {
	// ctx := context.Background()
	mariaDB, err := sql.Open("mysql", "root:1234@tcp(localhost:3306)/scribe_server")
	if err != nil {
		log.Fatal("Failed to connect to scribe_server database:", err)
	}
	defer mariaDB.Close()

	// Query to get all table names
	rows, err := mariaDB.Query("SELECT TABLE_NAME FROM information_schema.TABLES WHERE TABLE_SCHEMA = DATABASE()")
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to query tables: %v", err), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	// Collect table names
	var tables []string
	for rows.Next() {
		var tableName string
		if err := rows.Scan(&tableName); err != nil {
			http.Error(w, fmt.Sprintf("Failed to scan table name: %v", err), http.StatusInternalServerError)
			return
		}
		tables = append(tables, tableName)
	}

	// Check for any errors during iteration
	if err := rows.Err(); err != nil {
		http.Error(w, fmt.Sprintf("Error during rows iteration: %v", err), http.StatusInternalServerError)
		return
	}

	// Set content type and return JSON
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(tables); err != nil {
		http.Error(w, fmt.Sprintf("Failed to encode JSON: %v", err), http.StatusInternalServerError)
		return
	}
}

func getarabicadjectives(w http.ResponseWriter, r *http.Request) {
	// Get the context from the request.
	ctx := r.Context()

	// Open a new database connection (consider reusing a connection or pool in production).
	mariaDB, err := sql.Open("mysql", "root:1234@tcp(localhost:3306)/scribe_server")
	if err != nil {
		http.Error(w, "Database connection error", http.StatusInternalServerError)
		log.Printf("Failed to connect to scribe_server database: %v", err)
		return
	}
	defer mariaDB.Close()

	// Create a new Queries instance (generated by sqlc).
	queries := db.New(mariaDB)

	// Execute the generated query to fetch all rows.
	adjectives, err := queries.AR_arabic_db_adjectives(ctx)
	if err != nil {
		http.Error(w, "Failed to fetch adjectives", http.StatusInternalServerError)
		log.Printf("Error fetching adjectives: %v", err)
		return
	}

	// Prepare a slice of maps to hold the filtered results.
	var result []map[string]interface{}

	// Convert each record to a map and include only non-null, non-empty values.
	for _, adj := range adjectives {
		item := make(map[string]interface{})
		val := reflect.ValueOf(adj)
		typ := reflect.TypeOf(adj)
		for i := 0; i < val.NumField(); i++ {
			fieldVal := val.Field(i)
			fieldType := typ.Field(i)

			// Check if the field is a sql.NullString.
			if ns, ok := fieldVal.Interface().(sql.NullString); ok {
				if ns.Valid && ns.String != "" {
					item[fieldType.Name] = ns.String
				}
			} else {
				// For any non-sql.NullString fields (if any), add them as-is.
				item[fieldType.Name] = fieldVal.Interface()
			}
		}
		result = append(result, item)
	}

	// Set the header and encode the filtered results as JSON.
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(result); err != nil {
		http.Error(w, "Failed to encode adjectives", http.StatusInternalServerError)
		log.Printf("Error encoding adjectives: %v", err)
		return
	}
}
